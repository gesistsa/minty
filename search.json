[{"path":"http://gesistsa.github.io/minty/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 minty authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"http://gesistsa.github.io/minty/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Chung-hong Chan. Author, maintainer. Hadley Wickham. Author.            author ported code readr Jim Hester. Author.            author ported code readr Romain Francois. Contributor.            author ported code readr Jennifer Bryan. Author.            author ported code readr Shelby Bearrows. Contributor.            author ported code readr Posit Software, PBC. Copyright holder.            copyright holder readr David Olson. Author.            author src/tzfile.h","code":""},{"path":"http://gesistsa.github.io/minty/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Chan C, Wickham H, Hester J, Bryan J, Olson D (2024). minty: Minimal Type Guesser. R package version 0.0.4, https://github.com/gesistsa/minty, https://gesistsa.github.io/minty/.","code":"@Manual{,   title = {minty: Minimal Type Guesser},   author = {Chung-hong Chan and Hadley Wickham and Jim Hester and Jennifer Bryan and David Olson},   year = {2024},   note = {R package version 0.0.4, https://github.com/gesistsa/minty},   url = {https://gesistsa.github.io/minty/}, }"},{"path":"http://gesistsa.github.io/minty/index.html","id":"minty-","dir":"","previous_headings":"","what":"Minimal Type Guesser","title":"Minimal Type Guesser","text":"minty (Minimal type guesser) package type inferencing parsing tools (-called 1e parsing engine) extracted readr (permission, see issue tidyverse/readr#1517). Since July 2021, tools used internally readr parsing text files. Now vroom used default, unless explicitly call first edition parsing engine (see explanation editions). readr’s 1e type inferencing parsing tools used various R packages, e.g. readODS surveytoolbox parsing -memory objects, packages use main functions (e.g. readr::read_delim()) readr. explained README readr, 1e code eventually removed readr. minty aims providing set minimal, long-term, compatible type inferencing parsing tools packages. might consider minty 1.5e parsing engine.","code":""},{"path":"http://gesistsa.github.io/minty/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Minimal Type Guesser","text":"can install development version minty like :","code":"if (!require(\"remotes\")){     install.packages(\"remotes\") } remotes::install_github(\"gesistsa/minty\")"},{"path":"http://gesistsa.github.io/minty/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Minimal Type Guesser","text":"character-data.frame Inferencing column types","code":"text_only <- data.frame(maybe_age = c(\"17\", \"18\", \"019\"),                         maybe_male = c(\"true\", \"false\", \"true\"),                         maybe_name = c(\"AA\", \"BB\", \"CC\"),                         some_na = c(\"NA\", \"Not good\", \"Bad\"),                         dob = c(\"2019/07/21\", \"2019/08/31\", \"2019/10/01\")) str(text_only) #> 'data.frame':    3 obs. of  5 variables: #>  $ maybe_age : chr  \"17\" \"18\" \"019\" #>  $ maybe_male: chr  \"true\" \"false\" \"true\" #>  $ maybe_name: chr  \"AA\" \"BB\" \"CC\" #>  $ some_na   : chr  \"NA\" \"Not good\" \"Bad\" #>  $ dob       : chr  \"2019/07/21\" \"2019/08/31\" \"2019/10/01\" ## built-in function type.convert: ## except numeric, no type inferencing str(type.convert(text_only, as.is = TRUE)) #> 'data.frame':    3 obs. of  5 variables: #>  $ maybe_age : int  17 18 19 #>  $ maybe_male: chr  \"true\" \"false\" \"true\" #>  $ maybe_name: chr  \"AA\" \"BB\" \"CC\" #>  $ some_na   : chr  NA \"Not good\" \"Bad\" #>  $ dob       : chr  \"2019/07/21\" \"2019/08/31\" \"2019/10/01\" library(minty) data <- type_convert(text_only) data #>   maybe_age maybe_male maybe_name  some_na        dob #> 1        17       TRUE         AA     <NA> 2019-07-21 #> 2        18      FALSE         BB Not good 2019-08-31 #> 3       019       TRUE         CC      Bad 2019-10-01 str(data) #> 'data.frame':    3 obs. of  5 variables: #>  $ maybe_age : chr  \"17\" \"18\" \"019\" #>  $ maybe_male: logi  TRUE FALSE TRUE #>  $ maybe_name: chr  \"AA\" \"BB\" \"CC\" #>  $ some_na   : chr  NA \"Not good\" \"Bad\" #>  $ dob       : Date, format: \"2019-07-21\" \"2019-08-31\" ..."},{"path":"http://gesistsa.github.io/minty/index.html","id":"type-based-parsing-tools","dir":"","previous_headings":"Example","what":"Type-based parsing tools","title":"Minimal Type Guesser","text":"","code":"parse_datetime(\"1979-10-14T10:11:12.12345\") #> [1] \"1979-10-14 10:11:12 UTC\" fr <- locale(\"fr\") parse_date(\"1 janv. 2010\", \"%d %b %Y\", locale = fr) #> [1] \"2010-01-01\" de <- locale(\"de\", decimal_mark = \",\") parse_number(\"1.697,31\", local = de) #> [1] 1697.31 parse_number(\"$1,123,456.00\") #> [1] 1123456 ## This is perhaps Python parse_logical(c(\"True\", \"False\")) #> [1]  TRUE FALSE"},{"path":"http://gesistsa.github.io/minty/index.html","id":"type-guesser","dir":"","previous_headings":"Example","what":"Type guesser","title":"Minimal Type Guesser","text":"","code":"parse_guess(c(\"True\", \"TRUE\", \"false\", \"F\")) #> [1]  TRUE  TRUE FALSE FALSE parse_guess(c(\"123.45\", \"1990\", \"7619.0\")) #> [1]  123.45 1990.00 7619.00 res <- parse_guess(c(\"2019-07-21\", \"2019-08-31\", \"2019-10-01\", \"IDK\"), na = \"IDK\") res #> [1] \"2019-07-21\" \"2019-08-31\" \"2019-10-01\" NA str(res) #>  Date[1:4], format: \"2019-07-21\" \"2019-08-31\" \"2019-10-01\" NA"},{"path":"http://gesistsa.github.io/minty/index.html","id":"differences-readr-vs-minty","dir":"","previous_headings":"","what":"Differences: readr vs minty","title":"Minimal Type Guesser","text":"Unlike readr vroom, please note minty mainly non-interactive usage. Therefore, minty emits fewer messages warnings readr vroom. verbose option added like messages, default FALSE. keep package minimal possible, optional messages printed base R (cli). moment, minty use problems mechanism default. features vroom ported minty, readr. guess_max available parse_guess() type_convert(), default NA (readr). parse_guess() type_convert(), trim_ws considered type guessing (expected behavior vroom::vroom() / readr::read_delim()).","code":"data <- minty::type_convert(text_only) data #>   maybe_age maybe_male maybe_name  some_na        dob #> 1        17       TRUE         AA     <NA> 2019-07-21 #> 2        18      FALSE         BB Not good 2019-08-31 #> 3       019       TRUE         CC      Bad 2019-10-01 data <- readr::type_convert(text_only) #>  #> ── Column specification ──────────────────────────────────────────────────────── #> cols( #>   maybe_age = col_character(), #>   maybe_male = col_logical(), #>   maybe_name = col_character(), #>   some_na = col_character(), #>   dob = col_date(format = \"\") #> ) data #>   maybe_age maybe_male maybe_name  some_na        dob #> 1        17       TRUE         AA     <NA> 2019-07-21 #> 2        18      FALSE         BB Not good 2019-08-31 #> 3       019       TRUE         CC      Bad 2019-10-01 data <- minty::type_convert(text_only, verbose = TRUE) #> Column specification: #> cols(  maybe_age = col_character(),  maybe_male = col_logical(),  maybe_name = col_character(),  some_na = col_character(),  dob = col_date(format = \"\")) minty::parse_logical(c(\"true\", \"fake\", \"IDK\"), na = \"IDK\") #> [1] TRUE   NA   NA readr::parse_logical(c(\"true\", \"fake\", \"IDK\"), na = \"IDK\") #> Warning: 1 parsing failure. #> row col           expected actual #>   2  -- 1/0/T/F/TRUE/FALSE   fake #> [1] TRUE   NA   NA #> attr(,\"problems\") #> # A tibble: 1 × 4 #>     row   col expected           actual #>   <int> <int> <chr>              <chr>  #> 1     2    NA 1/0/T/F/TRUE/FALSE fake ## tidyverse/readr#1526 minty::type_convert(data.frame(a = c(\"NaN\", \"Inf\", \"-INF\"))) |> str() #> 'data.frame':    3 obs. of  1 variable: #>  $ a: num  NaN Inf -Inf readr::type_convert(data.frame(a = c(\"NaN\", \"Inf\", \"-INF\"))) |> str() #>  #> ── Column specification ──────────────────────────────────────────────────────── #> cols( #>   a = col_character() #> ) #> 'data.frame':    3 obs. of  1 variable: #>  $ a: chr  \"NaN\" \"Inf\" \"-INF\" minty::parse_guess(c(\"1\", \"2\", \"drei\")) #> [1] \"1\"    \"2\"    \"drei\" minty::parse_guess(c(\"1\", \"2\", \"drei\"), guess_max = 2) #> [1]  1  2 NA readr::parse_guess(c(\"1\", \"2\", \"drei\")) #> [1] \"1\"    \"2\"    \"drei\" minty::parse_guess(c(\"   1\", \" 2 \", \" 3  \"), trim_ws = TRUE) #> [1] 1 2 3 readr::parse_guess(c(\"   1\", \" 2 \", \" 3  \"), trim_ws = TRUE) #> [1] \"1\" \"2\" \"3\" ##tidyverse/readr#1536 minty::type_convert(data.frame(a = \"1 \", b = \" 2\"), trim_ws = TRUE) |> str() #> 'data.frame':    1 obs. of  2 variables: #>  $ a: num 1 #>  $ b: num 2 readr::type_convert(data.frame(a = \"1 \", b = \" 2\"), trim_ws = TRUE) |> str() #>  #> ── Column specification ──────────────────────────────────────────────────────── #> cols( #>   a = col_character(), #>   b = col_double() #> ) #> 'data.frame':    1 obs. of  2 variables: #>  $ a: chr \"1\" #>  $ b: num 2"},{"path":"http://gesistsa.github.io/minty/index.html","id":"similar-packages","dir":"","previous_headings":"","what":"Similar packages","title":"Minimal Type Guesser","text":"parsing ambiguous date(time) timeless anytime Guess column types text file hdd","code":""},{"path":"http://gesistsa.github.io/minty/index.html","id":"acknowledgements","dir":"","previous_headings":"","what":"Acknowledgements","title":"Minimal Type Guesser","text":"Thanks : Tidyverse Team allowing us spin code readr","code":""},{"path":"http://gesistsa.github.io/minty/reference/as.col_spec.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a column specification — as.col_spec","title":"Generate a column specification — as.col_spec","text":"useful generating specification using short form","code":""},{"path":"http://gesistsa.github.io/minty/reference/as.col_spec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a column specification — as.col_spec","text":"","code":"as.col_spec(x)"},{"path":"http://gesistsa.github.io/minty/reference/as.col_spec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a column specification — as.col_spec","text":"x Input object","code":""},{"path":"http://gesistsa.github.io/minty/reference/as.col_spec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a column specification — as.col_spec","text":"list / S3 object representing column specification","code":""},{"path":"http://gesistsa.github.io/minty/reference/as.col_spec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a column specification — as.col_spec","text":"","code":"as.col_spec(\"cccnnn\") #> cols( #>   col_character(), #>   col_character(), #>   col_character(), #>   col_number(), #>   col_number(), #>   col_number() #> )"},{"path":"http://gesistsa.github.io/minty/reference/cols.html","id":null,"dir":"Reference","previous_headings":"","what":"Create column specification — col_skip","title":"Create column specification — col_skip","text":"cols() includes columns input data, guessing column types default. cols_only() includes columns explicitly specify, skipping rest. general can substitute list() cols() without changing behavior.","code":""},{"path":"http://gesistsa.github.io/minty/reference/cols.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create column specification — col_skip","text":"","code":"col_skip()  cols(..., .default = col_guess())  cols_only(...)"},{"path":"http://gesistsa.github.io/minty/reference/cols.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create column specification — col_skip","text":"... Either column objects created col_*(), abbreviated character names (described col_types argument read_delim). overriding columns, best refer columns name. named, column types must match column names exactly. .default named columns explicitly overridden ... read column type.","code":""},{"path":"http://gesistsa.github.io/minty/reference/cols.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create column specification — col_skip","text":"list / S3 object representing column specification","code":""},{"path":"http://gesistsa.github.io/minty/reference/cols.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create column specification — col_skip","text":"available specifications : (string abbreviations brackets) col_logical() [l], containing T, F, TRUE FALSE. col_integer() [], integers. col_double() [d], doubles. col_character() [c], everything else. col_factor(levels, ordered) [f], fixed set values. col_date(format = \"\") [D]: locale's date_format. col_time(format = \"\") [t]: locale's time_format. col_datetime(format = \"\") [T]: ISO8601 date times col_number() [n], numbers containing grouping_mark col_skip() [_, -], import column. col_guess() [?], parse using \"best\" type based input.","code":""},{"path":[]},{"path":"http://gesistsa.github.io/minty/reference/cols.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create column specification — col_skip","text":"","code":"cols(a = col_integer()) #> cols( #>   a = col_integer() #> ) cols_only(a = col_integer()) #> cols_only( #>   a = col_integer() #> )  # You can also use the standard abbreviations cols(a = \"i\") #> cols( #>   a = col_integer() #> ) cols(a = \"i\", b = \"d\", c = \"_\") #> cols( #>   a = col_integer(), #>   b = col_double(), #>   c = col_skip() #> )  # You can also use multiple sets of column definitions by combining # them like so:  t1 <- cols(   column_one = col_integer(),   column_two = col_number() )  t2 <- cols(   column_three = col_character() )  t3 <- t1 t3$cols <- c(t1$cols, t2$cols) t3 #> cols( #>   column_one = col_integer(), #>   column_two = col_number(), #>   column_three = col_character() #> )"},{"path":"http://gesistsa.github.io/minty/reference/date_names.html","id":null,"dir":"Reference","previous_headings":"","what":"Create or retrieve date names — date_names","title":"Create or retrieve date names — date_names","text":"parsing dates, often need know weekdays week months represented text. pair functions allows either create , retrieve standard list. standard list derived ICU (http://site.icu-project.org) via stringi package.","code":""},{"path":"http://gesistsa.github.io/minty/reference/date_names.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create or retrieve date names — date_names","text":"","code":"date_names(mon, mon_ab = mon, day, day_ab = day, am_pm = c(\"AM\", \"PM\"))  date_names_lang(language)  date_names_langs()"},{"path":"http://gesistsa.github.io/minty/reference/date_names.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create or retrieve date names — date_names","text":"mon, mon_ab Full abbreviated month names. day, day_ab Full abbreviated week day names. Starts Sunday. am_pm Names used PM. language BCP 47 locale, made language region, e.g. \"en\" American English. See date_names_langs() complete list available locales.","code":""},{"path":"http://gesistsa.github.io/minty/reference/date_names.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create or retrieve date names — date_names","text":"list / S3 object representing data time","code":""},{"path":"http://gesistsa.github.io/minty/reference/date_names.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create or retrieve date names — date_names","text":"","code":"date_names_lang(\"en\") #> <date_names> #> Days:   Sunday (Sun), Monday (Mon), Tuesday (Tue), Wednesday (Wed), Thursday #>         (Thu), Friday (Fri), Saturday (Sat) #> Months: January (Jan), February (Feb), March (Mar), April (Apr), May (May), #>         June (Jun), July (Jul), August (Aug), September (Sep), October #>         (Oct), November (Nov), December (Dec) #> AM/PM:  AM/PM date_names_lang(\"ko\") #> <date_names> #> Days:   일요일 (일), 월요일 (월), 화요일 (화), 수요일 (수), 목요일 (목), 금요일 #>         (금), 토요일 (토) #> Months: 1월, 2월, 3월, 4월, 5월, 6월, 7월, 8월, 9월, 10월, 11월, 12월 #> AM/PM:  오전/오후 date_names_lang(\"fr\") #> <date_names> #> Days:   dimanche (dim.), lundi (lun.), mardi (mar.), mercredi (mer.), jeudi #>         (jeu.), vendredi (ven.), samedi (sam.) #> Months: janvier (janv.), février (févr.), mars (mars), avril (avr.), mai (mai), #>         juin (juin), juillet (juil.), août (août), septembre (sept.), #>         octobre (oct.), novembre (nov.), décembre (déc.) #> AM/PM:  AM/PM"},{"path":"http://gesistsa.github.io/minty/reference/locale.html","id":null,"dir":"Reference","previous_headings":"","what":"Create locales — locale","title":"Create locales — locale","text":"locale object tries capture defaults can vary countries. set locale , details automatically passed columns parsers. defaults chosen match R (.e. US English) closely possible.","code":""},{"path":"http://gesistsa.github.io/minty/reference/locale.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create locales — locale","text":"","code":"locale(   date_names = \"en\",   date_format = \"%AD\",   time_format = \"%AT\",   decimal_mark = \".\",   grouping_mark = \",\",   tz = \"UTC\",   encoding = \"UTF-8\",   asciify = FALSE )  default_locale()"},{"path":"http://gesistsa.github.io/minty/reference/locale.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create locales — locale","text":"date_names Character representations day month names. Either language code string (passed date_names_lang()) object created date_names(). date_format, time_format Default date time formats. decimal_mark, grouping_mark Symbols used indicate decimal place, chunk larger numbers. Decimal mark can , .. tz Default tz. used input (time zone present individual strings), output (control default display). default use \"UTC\", time zone use daylight savings time (DST) hence typically useful data. absence time zones makes approximately 50x faster generate UTC times time zone. Use \"\" use system default time zone, beware reproducible across systems. complete list possible time zones, see OlsonNames(). Americans, note \"EST\" Canadian time zone DST. Eastern Standard Time. better use \"US/Eastern\", \"US/Central\" etc. encoding Default encoding (used minty). asciify diacritics stripped date names converted ASCII? useful dealing ASCII data correct spellings lost. Requires stringi package.","code":""},{"path":"http://gesistsa.github.io/minty/reference/locale.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create locales — locale","text":"list / S3 object representing locale information","code":""},{"path":"http://gesistsa.github.io/minty/reference/locale.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create locales — locale","text":"","code":"locale() #> <locale> #> Numbers:  123,456.78 #> Formats:  %AD / %AT #> Timezone: UTC #> Encoding: UTF-8 #> <date_names> #> Days:   Sunday (Sun), Monday (Mon), Tuesday (Tue), Wednesday (Wed), Thursday #>         (Thu), Friday (Fri), Saturday (Sat) #> Months: January (Jan), February (Feb), March (Mar), April (Apr), May (May), #>         June (Jun), July (Jul), August (Aug), September (Sep), October #>         (Oct), November (Nov), December (Dec) #> AM/PM:  AM/PM locale(\"fr\") #> <locale> #> Numbers:  123,456.78 #> Formats:  %AD / %AT #> Timezone: UTC #> Encoding: UTF-8 #> <date_names> #> Days:   dimanche (dim.), lundi (lun.), mardi (mar.), mercredi (mer.), jeudi #>         (jeu.), vendredi (ven.), samedi (sam.) #> Months: janvier (janv.), février (févr.), mars (mars), avril (avr.), mai (mai), #>         juin (juin), juillet (juil.), août (août), septembre (sept.), #>         octobre (oct.), novembre (nov.), décembre (déc.) #> AM/PM:  AM/PM  # South American locale locale(\"es\", decimal_mark = \",\") #> <locale> #> Numbers:  123.456,78 #> Formats:  %AD / %AT #> Timezone: UTC #> Encoding: UTF-8 #> <date_names> #> Days:   domingo (dom), lunes (lun), martes (mar), miércoles (mié), jueves #>         (jue), viernes (vie), sábado (sáb) #> Months: enero (ene), febrero (feb), marzo (mar), abril (abr), mayo (may), junio #>         (jun), julio (jul), agosto (ago), septiembre (sept), octubre #>         (oct), noviembre (nov), diciembre (dic) #> AM/PM:  a. m./p. m."},{"path":"http://gesistsa.github.io/minty/reference/parse_atomic.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse logicals, integers, and reals — parse_atomic","title":"Parse logicals, integers, and reals — parse_atomic","text":"Use parse_*() character vector want parse.","code":""},{"path":"http://gesistsa.github.io/minty/reference/parse_atomic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse logicals, integers, and reals — parse_atomic","text":"","code":"parse_logical(   x,   na = c(\"\", \"NA\"),   locale = default_locale(),   trim_ws = TRUE,   .return_problems = FALSE )  parse_integer(   x,   na = c(\"\", \"NA\"),   locale = default_locale(),   trim_ws = TRUE,   .return_problems = FALSE )  parse_double(   x,   na = c(\"\", \"NA\"),   locale = default_locale(),   trim_ws = TRUE,   .return_problems = FALSE )  parse_character(   x,   na = c(\"\", \"NA\"),   locale = default_locale(),   trim_ws = TRUE,   .return_problems = FALSE )  col_logical()  col_integer()  col_double()  col_character()"},{"path":"http://gesistsa.github.io/minty/reference/parse_atomic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parse logicals, integers, and reals — parse_atomic","text":"x Character vector values parse. na Character vector strings interpret missing values. Set option character() indicate missing values. locale locale controls defaults vary place place. default locale US-centric (like R), can use locale() create locale controls things like default time zone, encoding, decimal mark, big mark, day/month names. trim_ws leading trailing whitespace (ASCII spaces tabs) trimmed field parsing ? .return_problems Whether hide problems tibble output","code":""},{"path":"http://gesistsa.github.io/minty/reference/parse_atomic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parse logicals, integers, and reals — parse_atomic","text":"parsed vector","code":""},{"path":[]},{"path":"http://gesistsa.github.io/minty/reference/parse_atomic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parse logicals, integers, and reals — parse_atomic","text":"","code":"parse_integer(c(\"1\", \"2\", \"3\")) #> [1] 1 2 3 parse_double(c(\"1\", \"2\", \"3.123\")) #> [1] 1.000 2.000 3.123 parse_number(\"$1,123,456.00\") #> [1] 1123456  # Use locale to override default decimal and grouping marks es_MX <- locale(\"es\", decimal_mark = \",\") parse_number(\"$1.123.456,00\", locale = es_MX) #> [1] 1123456  # Invalid values are replaced with missing values with a warning. x <- c(\"1\", \"2\", \"3\", \"-\") parse_double(x) #> [1]  1  2  3 NA # Or flag values as missing parse_double(x, na = \"-\") #> [1]  1  2  3 NA"},{"path":"http://gesistsa.github.io/minty/reference/parse_datetime.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse date/times — parse_datetime","title":"Parse date/times — parse_datetime","text":"Parse date/times","code":""},{"path":"http://gesistsa.github.io/minty/reference/parse_datetime.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse date/times — parse_datetime","text":"","code":"parse_datetime(   x,   format = \"\",   na = c(\"\", \"NA\"),   locale = default_locale(),   trim_ws = TRUE,   .return_problems = FALSE )  parse_date(   x,   format = \"\",   na = c(\"\", \"NA\"),   locale = default_locale(),   trim_ws = TRUE,   .return_problems = FALSE )  parse_time(   x,   format = \"\",   na = c(\"\", \"NA\"),   locale = default_locale(),   trim_ws = TRUE,   .return_problems = FALSE )  col_datetime(format = \"\")  col_date(format = \"\")  col_time(format = \"\")"},{"path":"http://gesistsa.github.io/minty/reference/parse_datetime.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parse date/times — parse_datetime","text":"x character vector dates parse. format format specification, described . set \"\", date times parsed ISO8601, dates times used date time formats specified locale(). Unlike strptime(), format specification must match complete string. na Character vector strings interpret missing values. Set option character() indicate missing values. locale locale controls defaults vary place place. default locale US-centric (like R), can use locale() create locale controls things like default time zone, encoding, decimal mark, big mark, day/month names. trim_ws leading trailing whitespace (ASCII spaces tabs) trimmed field parsing ? .return_problems Whether hide problems tibble output","code":""},{"path":"http://gesistsa.github.io/minty/reference/parse_datetime.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parse date/times — parse_datetime","text":"POSIXct() vector tzone attribute set tz. Elements parsed (generate valid dates) set NA, warning message inform total number failures.","code":""},{"path":"http://gesistsa.github.io/minty/reference/parse_datetime.html","id":"format-specification","dir":"Reference","previous_headings":"","what":"Format specification","title":"Parse date/times — parse_datetime","text":"minty (inherited readr) uses format specification similar strptime(). three types element: Date components specified \"%\" followed letter. example \"%Y\" matches 4 digit year, \"%m\", matches 2 digit month \"%d\" matches 2 digit day. Month day default 1, (.e. Jan 1st) present, example year given. Whitespace sequence zero whitespace characters. character matched exactly. parse_datetime() recognises following format specifications: Year: \"%Y\" (4 digits). \"%y\" (2 digits); 00-69 -> 2000-2069, 70-99 -> 1970-1999. Month: \"%m\" (2 digits), \"%b\" (abbreviated name current locale), \"%B\" (full name current locale). Day: \"%d\" (2 digits), \"%e\" (optional leading space), \"%\" (abbreviated name current locale). Hour: \"%H\" \"%\" \"%h\", use (H) /PM, use h (H) times represent durations longer one day. Minutes: \"%M\" Seconds: \"%S\" (integer seconds), \"%OS\" (partial seconds) Time zone: \"%Z\" (name, e.g. \"America/Chicago\"), \"%z\" (offset UTC, e.g. \"+0800\") /PM indicator: \"%p\". Non-digits: \"%.\" skips one non-digit character, \"%+\" skips one non-digit characters, \"%*\" skips number non-digits characters. Automatic parsers: \"%AD\" parses flexible YMD parser, \"%\" parses flexible HMS parser. Time since Unix epoch: \"%s\" decimal seconds since Unix epoch. Shortcuts: \"%D\" = \"%m/%d/%y\", \"%F\" = \"%Y-%m-%d\", \"%R\" = \"%H:%M\", \"%T\" = \"%H:%M:%S\", \"%x\" = \"%y/%m/%d\".","code":""},{"path":"http://gesistsa.github.io/minty/reference/parse_datetime.html","id":"iso-support","dir":"Reference","previous_headings":"","what":"ISO8601 support","title":"Parse date/times — parse_datetime","text":"Currently, minty support ISO8601. Missing features: Week & weekday specifications, e.g. \"2013-W05\", \"2013-W05-10\". Ordinal dates, e.g. \"2013-095\". Using commas instead period decimal separator. parser also little laxer ISO8601: Dates times can separated space, just T. Mostly correct specifications like \"2009-05-19 14:\" \"200912-01\" work.","code":""},{"path":[]},{"path":"http://gesistsa.github.io/minty/reference/parse_datetime.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parse date/times — parse_datetime","text":"","code":"# Format strings -------------------------------------------------------- parse_datetime(\"01/02/2010\", \"%d/%m/%Y\") #> [1] \"2010-02-01 UTC\" parse_datetime(\"01/02/2010\", \"%m/%d/%Y\") #> [1] \"2010-01-02 UTC\" # Handle any separator parse_datetime(\"01/02/2010\", \"%m%.%d%.%Y\") #> [1] \"2010-01-02 UTC\"  # Dates look the same, but internally they use the number of days since # 1970-01-01 instead of the number of seconds. This avoids a whole lot # of troubles related to time zones, so use if you can. parse_date(\"01/02/2010\", \"%d/%m/%Y\") #> [1] \"2010-02-01\" parse_date(\"01/02/2010\", \"%m/%d/%Y\") #> [1] \"2010-01-02\"  # You can parse timezones from strings (as listed in OlsonNames()) parse_datetime(\"2010/01/01 12:00 US/Central\", \"%Y/%m/%d %H:%M %Z\") #> [1] \"2010-01-01 18:00:00 UTC\" # Or from offsets parse_datetime(\"2010/01/01 12:00 -0600\", \"%Y/%m/%d %H:%M %z\") #> [1] \"2010-01-01 18:00:00 UTC\"  # Use the locale parameter to control the default time zone # (but note UTC is considerably faster than other options) parse_datetime(\"2010/01/01 12:00\", \"%Y/%m/%d %H:%M\",   locale = locale(tz = \"US/Central\") ) #> [1] \"2010-01-01 12:00:00 CST\" parse_datetime(\"2010/01/01 12:00\", \"%Y/%m/%d %H:%M\",   locale = locale(tz = \"US/Eastern\") ) #> [1] \"2010-01-01 12:00:00 EST\"  # Unlike strptime, the format specification must match the complete # string (ignoring leading and trailing whitespace). This avoids common # errors: strptime(\"01/02/2010\", \"%d/%m/%y\") #> [1] \"2020-02-01 UTC\" parse_datetime(\"01/02/2010\", \"%d/%m/%y\") #> [1] NA  # Failures ------------------------------------------------------------- parse_datetime(\"01/01/2010\", \"%d/%m/%Y\") #> [1] \"2010-01-01 UTC\" parse_datetime(c(\"01/ab/2010\", \"32/01/2010\"), \"%d/%m/%Y\") #> [1] NA NA  # Locales -------------------------------------------------------------- # By default, readr expects English date/times, but that's easy to change' parse_datetime(\"1 janvier 2015\", \"%d %B %Y\", locale = locale(\"fr\")) #> [1] \"2015-01-01 UTC\" parse_datetime(\"1 enero 2015\", \"%d %B %Y\", locale = locale(\"es\")) #> [1] \"2015-01-01 UTC\"  # ISO8601 -------------------------------------------------------------- # With separators parse_datetime(\"1979-10-14\") #> [1] \"1979-10-14 UTC\" parse_datetime(\"1979-10-14T10\") #> [1] \"1979-10-14 10:00:00 UTC\" parse_datetime(\"1979-10-14T10:11\") #> [1] \"1979-10-14 10:11:00 UTC\" parse_datetime(\"1979-10-14T10:11:12\") #> [1] \"1979-10-14 10:11:12 UTC\" parse_datetime(\"1979-10-14T10:11:12.12345\") #> [1] \"1979-10-14 10:11:12 UTC\"  # Without separators parse_datetime(\"19791014\") #> [1] \"1979-10-14 UTC\" parse_datetime(\"19791014T101112\") #> [1] \"1979-10-14 10:11:12 UTC\"  # Time zones us_central <- locale(tz = \"US/Central\") parse_datetime(\"1979-10-14T1010\", locale = us_central) #> [1] \"1979-10-14 10:10:00 CDT\" parse_datetime(\"1979-10-14T1010-0500\", locale = us_central) #> [1] \"1979-10-14 10:10:00 CDT\" parse_datetime(\"1979-10-14T1010Z\", locale = us_central) #> [1] \"1979-10-14 05:10:00 CDT\" # Your current time zone parse_datetime(\"1979-10-14T1010\", locale = locale(tz = \"\")) #> [1] \"1979-10-14 10:10:00 UTC\""},{"path":"http://gesistsa.github.io/minty/reference/parse_factor.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse factors — parse_factor","title":"Parse factors — parse_factor","text":"parse_factor() similar factor().","code":""},{"path":"http://gesistsa.github.io/minty/reference/parse_factor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse factors — parse_factor","text":"","code":"parse_factor(   x,   levels = NULL,   ordered = FALSE,   na = c(\"\", \"NA\"),   locale = default_locale(),   include_na = TRUE,   trim_ws = TRUE,   .return_problems = FALSE )  col_factor(levels = NULL, ordered = FALSE, include_na = FALSE)"},{"path":"http://gesistsa.github.io/minty/reference/parse_factor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parse factors — parse_factor","text":"x Character vector values parse. levels Character vector allowed levels. levels = NULL (default), levels discovered unique values x, order appear x. ordered ordered factor? na Character vector strings interpret missing values. Set option character() indicate missing values. locale locale controls defaults vary place place. default locale US-centric (like R), can use locale() create locale controls things like default time zone, encoding, decimal mark, big mark, day/month names. include_na TRUE x contains least one NA, NA included levels constructed factor. trim_ws leading trailing whitespace (ASCII spaces tabs) trimmed field parsing ? .return_problems Whether hide problems tibble output","code":""},{"path":"http://gesistsa.github.io/minty/reference/parse_factor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parse factors — parse_factor","text":"parsed vector","code":""},{"path":[]},{"path":"http://gesistsa.github.io/minty/reference/parse_factor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parse factors — parse_factor","text":"","code":"# discover the levels from the data parse_factor(c(\"a\", \"b\")) #> [1] a b #> Levels: a b parse_factor(c(\"a\", \"b\", \"-99\")) #> [1] a   b   -99 #> Levels: a b -99 parse_factor(c(\"a\", \"b\", \"-99\"), na = c(\"\", \"NA\", \"-99\")) #> [1] a    b    <NA> #> Levels: a b <NA> parse_factor(c(\"a\", \"b\", \"-99\"), na = c(\"\", \"NA\", \"-99\"), include_na = FALSE) #> [1] a    b    <NA> #> Levels: a b  # provide the levels explicitly parse_factor(c(\"a\", \"b\"), levels = letters[1:5]) #> [1] a b #> Levels: a b c d e  x <- c(\"cat\", \"dog\", \"caw\") animals <- c(\"cat\", \"dog\", \"cow\")  # base::factor() silently converts elements that do not match any levels to # NA factor(x, levels = animals) #> [1] cat  dog  <NA> #> Levels: cat dog cow  # parse_factor() generates same factor as base::factor() but throws a warning # and reports problems parse_factor(x, levels = animals) #> [1] cat  dog  <NA> #> Levels: cat dog cow"},{"path":"http://gesistsa.github.io/minty/reference/parse_guess.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse using the ","title":"Parse using the ","text":"parse_guess() returns parser vector. function uses number heuristics determine type vector \"best\". Generally try err side safety, straightforward override parsing choice needed.","code":""},{"path":"http://gesistsa.github.io/minty/reference/parse_guess.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse using the ","text":"","code":"parse_guess(   x,   na = c(\"\", \"NA\"),   locale = default_locale(),   trim_ws = TRUE,   guess_integer = FALSE,   guess_max = NA,   .return_problems = FALSE )  col_guess()"},{"path":"http://gesistsa.github.io/minty/reference/parse_guess.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parse using the ","text":"x Character vector values parse. na Character vector strings interpret missing values. Set option character() indicate missing values. locale locale controls defaults vary place place. default locale US-centric (like R), can use locale() create locale controls things like default time zone, encoding, decimal mark, big mark, day/month names. trim_ws leading trailing whitespace (ASCII spaces tabs) trimmed field parsing ? guess_integer TRUE, guess integer types whole numbers, FALSE guess numeric type numbers. guess_max Maximum number data rows use guessing column types. NA: uses data. .return_problems Whether hide problems tibble output","code":""},{"path":"http://gesistsa.github.io/minty/reference/parse_guess.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parse using the ","text":"parsed vector","code":""},{"path":[]},{"path":"http://gesistsa.github.io/minty/reference/parse_guess.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parse using the ","text":"","code":"# Logical vectors parse_guess(c(\"FALSE\", \"TRUE\", \"F\", \"T\")) #> [1] FALSE  TRUE FALSE  TRUE  # Integers and doubles parse_guess(c(\"1\", \"2\", \"3\")) #> [1] 1 2 3 parse_guess(c(\"1.6\", \"2.6\", \"3.4\")) #> [1] 1.6 2.6 3.4  # Numbers containing grouping mark parse_guess(\"1,234,566\") #> [1] 1234566  # ISO 8601 date times parse_guess(c(\"2010-10-10\")) #> [1] \"2010-10-10\""},{"path":"http://gesistsa.github.io/minty/reference/parse_number.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse numbers, flexibly — parse_number","title":"Parse numbers, flexibly — parse_number","text":"parses first number finds, dropping non-numeric characters first number characters first number. grouping mark specified locale ignored inside number.","code":""},{"path":"http://gesistsa.github.io/minty/reference/parse_number.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse numbers, flexibly — parse_number","text":"","code":"parse_number(   x,   na = c(\"\", \"NA\"),   locale = default_locale(),   trim_ws = TRUE,   .return_problems = FALSE )  col_number()"},{"path":"http://gesistsa.github.io/minty/reference/parse_number.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parse numbers, flexibly — parse_number","text":"x Character vector values parse. na Character vector strings interpret missing values. Set option character() indicate missing values. locale locale controls defaults vary place place. default locale US-centric (like R), can use locale() create locale controls things like default time zone, encoding, decimal mark, big mark, day/month names. trim_ws leading trailing whitespace (ASCII spaces tabs) trimmed field parsing ? .return_problems Whether hide problems tibble output","code":""},{"path":"http://gesistsa.github.io/minty/reference/parse_number.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parse numbers, flexibly — parse_number","text":"numeric vector (double) parsed numbers. parsed vector","code":""},{"path":[]},{"path":"http://gesistsa.github.io/minty/reference/parse_number.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parse numbers, flexibly — parse_number","text":"","code":"## These all return 1000 parse_number(\"$1,000\") ## leading `$` and grouping character `,` ignored #> [1] 1000 parse_number(\"euro1,000\") ## leading non-numeric euro ignored #> [1] 1000 parse_number(\"t1000t1000\") ## only parses first number found #> [1] 1000  parse_number(\"1,234.56\") #> [1] 1234.56 ## explicit locale specifying European grouping and decimal marks parse_number(\"1.234,56\", locale = locale(decimal_mark = \",\", grouping_mark = \".\")) #> [1] 1234.56 ## SI/ISO 31-0 standard spaces for number grouping parse_number(\"1 234.56\", locale = locale(decimal_mark = \".\", grouping_mark = \" \")) #> [1] 1234.56  ## Specifying strings for NAs parse_number(c(\"1\", \"2\", \"3\", \"NA\")) #> [1]  1  2  3 NA parse_number(c(\"1\", \"2\", \"3\", \"NA\", \"Nothing\"), na = c(\"NA\", \"Nothing\")) #> [1]  1  2  3 NA NA"},{"path":"http://gesistsa.github.io/minty/reference/parse_vector.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse a character vector. — parse_vector","title":"Parse a character vector. — parse_vector","text":"Parse character vector.","code":""},{"path":"http://gesistsa.github.io/minty/reference/parse_vector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse a character vector. — parse_vector","text":"","code":"parse_vector(   x,   collector,   na = c(\"\", \"NA\"),   locale = default_locale(),   trim_ws = TRUE,   .return_problems = FALSE )"},{"path":"http://gesistsa.github.io/minty/reference/parse_vector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parse a character vector. — parse_vector","text":"x Character vector elements parse. collector Column specification. .return_problems Whether hide problems tibble output","code":""},{"path":"http://gesistsa.github.io/minty/reference/parse_vector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parse a character vector. — parse_vector","text":"parsed vector","code":""},{"path":[]},{"path":"http://gesistsa.github.io/minty/reference/parse_vector.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parse a character vector. — parse_vector","text":"","code":"x <- c(\"1\", \"2\", \"3\", \"NA\") parse_vector(x, col_integer()) #> [1]  1  2  3 NA parse_vector(x, col_double()) #> [1]  1  2  3 NA"},{"path":"http://gesistsa.github.io/minty/reference/type_convert.html","id":null,"dir":"Reference","previous_headings":"","what":"Re-convert character columns in existing data frame — type_convert","title":"Re-convert character columns in existing data frame — type_convert","text":"useful need manual munging - can read columns character, clean (e.g.) regular expressions let readr take another stab parsing . name homage base utils::type.convert().","code":""},{"path":"http://gesistsa.github.io/minty/reference/type_convert.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Re-convert character columns in existing data frame — type_convert","text":"","code":"type_convert(   df,   col_types = NULL,   na = c(\"\", \"NA\"),   trim_ws = TRUE,   locale = default_locale(),   guess_integer = FALSE,   guess_max = NA,   verbose = FALSE )"},{"path":"http://gesistsa.github.io/minty/reference/type_convert.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Re-convert character columns in existing data frame — type_convert","text":"df data frame. col_types One NULL, cols() specification, string. NULL, column types imputed using rows. na Character vector strings interpret missing values. Set option character() indicate missing values. trim_ws leading trailing whitespace (ASCII spaces tabs) trimmed field parsing ? locale locale controls defaults vary place place. default locale US-centric (like R), can use locale() create locale controls things like default time zone, encoding, decimal mark, big mark, day/month names. guess_integer TRUE, guess integer types whole numbers, FALSE guess numeric type numbers. guess_max Maximum number data rows use guessing column types. NA: uses data. verbose whether print messages","code":""},{"path":"http://gesistsa.github.io/minty/reference/type_convert.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Re-convert character columns in existing data frame — type_convert","text":"data frame","code":""},{"path":"http://gesistsa.github.io/minty/reference/type_convert.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Re-convert character columns in existing data frame — type_convert","text":"type_convert() removes 'spec' attribute (presents).","code":""},{"path":"http://gesistsa.github.io/minty/reference/type_convert.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Re-convert character columns in existing data frame — type_convert","text":"","code":"df <- data.frame(   x = as.character(runif(10)),   y = as.character(sample(10)),   stringsAsFactors = FALSE ) str(df) #> 'data.frame':\t10 obs. of  2 variables: #>  $ x: chr  \"0.0807501375675201\" \"0.834333037259057\" \"0.600760886212811\" \"0.157208441523835\" ... #>  $ y: chr  \"6\" \"9\" \"5\" \"8\" ... str(type_convert(df)) #> 'data.frame':\t10 obs. of  2 variables: #>  $ x: num  0.0808 0.8343 0.6008 0.1572 0.0074 ... #>  $ y: num  6 9 5 8 7 2 10 3 1 4  df <- data.frame(x = c(\"NA\", \"10\"), stringsAsFactors = FALSE) str(type_convert(df)) #> 'data.frame':\t2 obs. of  1 variable: #>  $ x: num  NA 10"}]
